<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<pre>
			1.RegExp 对象
				正则表达式是描述字符模式的对象。
				正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。
			2.语法
				var patt=new RegExp(pattern,modifiers);
				或者更简单的方式:
				var patt=/pattern/modifiers;
				pattern（模式） 	描述了表达式的模式
				modifiers(修饰符) 	用于指定全局匹配、区分大小写的匹配和多行匹配
				
				当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：
				var re = new RegExp("\\w+");
				var re = /\w+/;
			3.修饰符
				修饰符用于执行区分大小写和全局匹配:
				修饰符	描述
				i	执行对大小写不敏感的匹配。
				g	执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。
				m	执行多行匹配。
			4.方括号
				方括号用于查找某个范围内的字符：
				表达式	描述
				[abc]			查找方括号之间的任何字符。
				[^abc]			查找任何不在方括号之间的字符。
				[0-9]			查找任何从 0 至 9 的数字。
				[a-z]			查找任何从小写 a 到小写 z 的字符。
				[A-Z]			查找任何从大写 A 到大写 Z 的字符。
				[A-z]			查找任何从大写 A 到小写 z 的字符。
				[adgk]			查找给定集合内的任何字符。
				[^adgk]			查找给定集合外的任何字符。
				(red|blue|green)	查找任何指定的选项。
			5.元字符(预定义模式)
				元字符（Metacharacter）是拥有特殊含义的字符：
				元字符	描述
				.	查找单个字符，除了换行和行结束符。
				\w	查找单词字符。(\w 元字符用于查找单词字符。
					单词字符包括：a-z、A-Z、0-9，以及下划线, 包含 _ (下划线) 字符。)
				\W	查找非单词字符。
				\d	查找数字。
				\D	查找非数字字符。
				\s	查找空白字符。
				\S	查找非空白字符。
				\b	匹配单词边界。
				\B	匹配非单词边界。
			6.量词
				量词		描述
				n+		匹配任何包含至少一个 n 的字符串。
						例如，/a+/ 匹配 "candy" 中的 "a"，"caaaaaaandy" 中所有的 "a"。
				n*		匹配任何包含零个或多个 n 的字符串。
						例如，/bo*/ 匹配 "A ghost booooed" 中的 "boooo"，
						"A bird warbled" 中的 "b"，但是不匹配 "A goat grunted"。
				n?		匹配任何包含零个或一个 n 的字符串。
						例如，/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"。
				n{X}		匹配包含 X 个 n 的序列的字符串。
						例如，/a{2}/ 不匹配 "candy," 中的 "a"，但是匹配 "caandy," 
						中的两个 "a"，且匹配 "caaandy." 中的前两个 "a"。
				n{X,}		X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。
						例如，/a{2,}/ 不匹配 "candy" 中的 "a"，但是匹配 "caandy" 和 "caaaaaaandy." 中所有的 "a"。
				n{X,Y}		X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。
						例如，/a{1,3}/ 不匹配 "cndy"，匹配 "candy," 中的 "a"，"caandy," 中的两个 "a"，
						匹配 "caaaaaaandy" 中的前面三个 "a"。注意，当匹配 "caaaaaaandy" 时，
						即使原始字符串拥有更多的 "a"，匹配项也是 "aaa"。
				n$		匹配任何结尾为 n 的字符串。
						
				^n		匹配任何开头为 n 的字符串。
				
				?=n		匹配任何其后紧接指定字符串 n 的字符串。
						
				?!n		匹配任何其后没有紧接指定字符串 n 的字符串。
				
			\		将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
					例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
			^		匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
			$		匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
			*		匹配前面的子表达式零次或多次。
					例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
			+		匹配前面的子表达式一次或多次。
					例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
			?		匹配前面的子表达式零次或一次。
					例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
			{n}		n 是一个非负整数。匹配确定的 n 次。
					例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
			{n,}		n 是一个非负整数。至少匹配n 次。
						例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
			{n,m}		m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
					例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
			?		当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。
							非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。
							例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
			.		匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
			(pattern)	匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到
			(?:pattern)	匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。
					这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。
			(?=pattern)	正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。
					这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
			(?!pattern)	正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。
					这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
			(?<!pattern)	反向否定预查，与正向否定预查类似，只是方向相反。
			x|y		匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
			[xyz]		字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
			[^xyz]		负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
			[a-z]		字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
			[^a-z]		负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
			\b		匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
			\B		匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
			\d		匹配一个数字字符。等价于 [0-9]。
			\D		匹配一个非数字字符。等价于 [^0-9]。
			\w		匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。
			\W		匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。
			
			////////////////////////////
				var str1="abcd";
				var patt1=/d$/;
				var f1=patt1.test(str1);
				console.log("f1:",f1);
				var patt2=/^a/;
				var f2=patt2.test(str1);
				console.log("f2:",f2);
				var str3="Is this all there is";//Is this all there is,其中this all,中的is是匹配的
				var patt3=/is(?= all)/;
				var f3=patt3.test(str3);
				console.log("f3:",f3);
				console.log("//////////////");
				var patt33=new RegExp("is(?= all)");
				var f33=patt33.test(str3);
				console.log("f33:",f33);
				
				
				var str4="Is this all there is";
				var patt4=/is(?! all)/gi;
				var f4=patt4.test(str4);
				console.log("f4:",f4);//Is this all there is,其中IS,is值匹配的.
				console.log("//////////////");
				var patt44=new RegExp("is(?! all)","gi");
				var f44=patt44.test(str4);
				console.log("f44:",f44);//Is this all there is,其中IS,is值匹配的.
			////////////////////////////
				var patt=/e/;
				var str="The best things in life are free!";
				var f1=patt.test(str);
				var f2=/e/.test(str);
				console.log("f1:",f1);
				console.log("f2:",f2);
			////////////////////////////
			14.Demo
				1.JS判断输入字符串是否为数字,字母,下划线组成
				2.JS判断输入字符串是否全部为字母
				3.JS判断输入字符串是否全部为数字
				//////////////////
			var patt1=/^\w+$/;
			var patt2=/^[a-zA-Z]+$/;
			var patt3=/^\d+$/;
			btn1.onclick=function(){
				var str=ipt.value;
				check(str);
				var f1=patt1.test(str);
				console.log("f1:",f1);
			}
			btn2.onclick=function(){
				var str=ipt.value;
				check(str);
				var f2=patt2.test(str);
				console.log("f2:",f2);
			}
			btn3.onclick=function(){
				var str=ipt.value;
				check(str);
				var f3=patt3.test(str);
				console.log("f3:",f3);
			}
			function check(str){
				var str=ipt.value;
				if(str=="" || str==undefined){
					alert("请输入内容")
					return;
				}
			}
				//////////////////
		
		</pre>
	</body>
</html>
